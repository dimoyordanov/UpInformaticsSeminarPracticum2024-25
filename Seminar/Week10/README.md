# Символни низове и функции

Основната разлика между символните низове и масивите е, че символните низове завършват винаги с терминираща нула '\0', която указва края на низа.

```c
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
char str[] = "Hello";
```

## Важни фунцкии:
```c
#include <string.h> 

strlen(str); // Връща дължината на низа без терминиращата 0

strcpy(str1, str2); // Копира съдържанието на str2 в str1
// Съществува и strncpy

Важни недостатъци:

char null_in_middle[] = "Drasti\0Pichue"
char copy[255];
char *res1 = strcpy(null_in_middle, copy); // copy ще съдържа само "Drasti"

char too_small[2];
char *res2 = strcpy(too_small, "Golqm"); // buffer overflow
---------------------------------------------------------------------

memcpy(str1, str2, n); // Копира първите n символа от str2 в str1, ako n > strlen(str2) копира strlen(str2) символа

Фунцкцията решава проблема с null-terminated низовете, но създава нов при препокриване на паметта:

char str[100] = "Hello";
memcpy(str + 4, str, strlen(str) + 1); // undefined behavior

memmove(str1, str2, n); // Копира първите n символа от str2 в str1, като първо прехвърля данните във временен буфер

memmove(str + 4, str, strlen(str) + 1); // str ще съдържа "HelHello"

---------------------------------------------------------------------
strcmp(str1, str2); // Сравнява str1 и str2. Връща 0, ако са равни, < 0, ако str1 < str2, > 0, ако str1 > str2

strcat(str1, str2); // Конкатенира str2 към края на str1

strchr(str, ch); // Връща указател към първото срещане на ch в str, ако не намери връща NULL

strstr(str1, str2); // Връща указател към първото срещане на str2 в str1, ако не намери връща NULL

strtok(str, delim); // Разделя низа на токени, разделени от символите в delim
```

## Четене и писане
```c
char str[255]; // 254 символа + 1 за терминираща 0('\0')

scanf("%s", str); // Не е безопасен начин за въвеждане на низ, защото може да доведе до buffer overflow

scanf("%254s", str); // Чете максимум 254 символа от стандартния вход, за да не доведе до buffer overflow 

Тук обаче нямаме начин да се справим с whitespace символите

scanf("%254[^\n]s", str); // Чете до нов ред

printf("%s", str); // Извеждане на стандартния изход

getchar(); // Връща следващия символ от стандартния вход като int

sprintf(str, "%d", n); // Записва числото n в низа str

fgets(str, 255, stdin); // Въвеждане на низ от стандартния вход с дължина до 254 символа

gets(str); // Въвеждане на низ от стандартния вход, докато не се срещне нов ред (по-небезопасен от fgets, защото може да доведе до buffer overflow)

fputs(str, stdout); // Извеждане на низ на стандартния изход

puts(str); // Извеждане на низ на стандартния изход, последван от нов ред
```

<h1>Задачи</h1>

**Задача 1** Да се напише програма, която приема низ и единичен символ и връща, колко пъти се среща символът в низа.

*Вход: ababbbccba a Изход: 3*

**Задача 2** Да се напише програма, която приема низ и проверява, какъв е броят на малки букви, големи букви и цифри.

*Вход: Aaab1Ba5Bab2b Изход: Uppercase: 3; Lowercase: 7; Digits: 3;*

**Задача 3** Да се напише програма, която приема низ. Програмата да прави главните букви малки и малките букви главни.

*Вход: AAAbbaaBaBB Изход: aaaBBAAbAbb*

**Задача 4** Да се напише програма, която приема низ и принтира максималният брой символи между две големи букви.

*Вход: jwislaowAkslawofOlsaQlkasG Изход: 7*

**Задача 5** Да се напише програма, която приема низ и премахва всички празни места в него(' ').

*Вход: Hello there my friends it's nice to meet you. Изход: Hellotheremyfriendsit'snicetomeetyou.*

**Задача 6** Да се напише програма, която намира дали един низ е плаиндром.

*Вход: AaABBbBBAaA Изход: true*
*Вход: skjwiaonsse Изход: true*

**Задача 7** Да се напише програма, която приема низ и намира най-късата и най-дългата дума в него.

*Вход: Hello there my friends it's nice to meet you. Изход: friends my*
