# Цикличност

## for

```c
for (initialization; condition; increment)
{
    // Тяло на цикъла
}
```
- `initialization` - изпълнява се само веднъж в началото на цикъла.
- `condition` - проверява се преди всяка итерация на цикъла. Ако условието е изпълнено, се изпълнява тялото на цикъла.
- `increment` - изпълнява се след всяка итерация на цикъла.

Цикълът протича по следния начин:
1. Изпълнява се `initialization`.
2. Проверява се `condition`. Ако е изпълнено, се изпълнява тялото на цикъла, в противен случай цикълът приключва.
3. Изпълнява се `increment`.
4. Повтаря се стъпка 2.

### Пример:

```c
#include <iostream>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", i);
    }
}
```

```
Изход:
0 1 2 3 4 5 6 7 8 9
```

## while

```c
while (<condition>)
{
    // Тяло на цикъла
}
```

## do-while

```c
do
{
    // Тяло на цикъла
} while (<condition>);
```

**В тялото на всеки цикъл могат да се използват запазените думи `break` и `continue`.**

- `continue` - прекратява текущото изпълнение на цикъла и продължава със следващата итерация.
- `break` - прекратява изпълнението на цикъла и продължава изпълнението на програмата след цикъла.

### Пример:

```c
#include <stdio.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            continue;
        }
        else if (i == 7)
        {
            break;
        }
        printf("%d ", i);
    }
}
```

```
Изход:
0 1 2 3 4 6
```

**Важно**: Внимавайте като използвате променливи без знак (unsigned) в условията на `for` циклите, тъй като те могат да `превъртят` и да влязат в безкраен цикъл.

```c
#include <stdio.h>

int main()
{
    // В момента в който i стане по-малко от 0, то ще се "превърти" и ще заеме своята най-висока възможна стойност, съответно цикълът никога не приключва изпълнение
    for (unsigned int i = 10; i >= 0; i--)
    {
        printf("%d ", i); 
    }

    return 0;
}
```

## Задачи

**За всички задачи не забравяйте да правите проверка за коректност на входа. Ако входът е невалиден, питайте потребителя за нов вход, докато не бъде въведен валиден такъв.**

### Задача 1.
Напишете програма, която въвежда цяло положително число **n** и изпечатва най-близката до него степен на 2. Ако по-малкото и по-голямото число са на равно отстояние от въведеното, отпечатайте по-голямото.

```
Вход: 6 // 2^2 = 4, 2^3 = 8, и двете са на отстояние 2
Изход: 8 

Вход: 11458
Изход: 16384
```

### Задача 2.
Напишете програма, която проверява дали въведенo естествено число **n** е просто.

```
Вход: 5
Изход: Prime

Вход: 6
Изход: Composite
```

### Задача 3.
Напишете програма, която въвежда цяло положително число **n** и проверява дали то е палиндром.

```
Вход: 12321
Изход: Palindrome

Вход: 12345
Изход: Just a number
```


### Задача 4.
Напишете програма, която приема поток от цели числа, докато не срещне 0. Програмата трябва да изведе сумата на всички числа.

```
Вход: 1 2 3 4 5 6 7 8 9 0
Изход: 45

Вход: 5 7 5 0
Изход: 17
```

### Задача 5.
Напишете програма, която отпечатва триъгълника на Паскал. Въведете цяло число **n** и отпечатайте пирамидата до **n**-ти ред.

```
Вход: 5
Изход:
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
```

### Задача 6.
Отпечатайте подобна фигура, като предварително питате потребителя за броя редове, които да бъдат принтирани.
```
Вход: 4
Изход:
    *
   * *
  * * *
 * * * *  
```