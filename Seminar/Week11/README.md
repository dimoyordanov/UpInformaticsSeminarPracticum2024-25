# Рекурсия

## Рекурсивни функции

Рекурсивните функции са функции, които извикват сами себе си. Те се използват за решаване на задачи, които могат да се разделят на по-малки подзадачи.
<br> Както знаем, всяко ново извикване на функция пълни стека, като се запазва текущото състояние на функцията. При рекурсивни функции, ако не се стигне до дъното на рекурсията, стекът ще се запълни и ще се получи грешка "`stack overflow`".

## Елементи на рекурсивна функция

1. **Дъно на рекурсията** - условието, необходимо, за да не се получи "`stack overflow`".

2. **Рекурсивно извикване** - извикване на същата функция в тялото на функцията. Трябва да сме сигурни, че то ще промени нещо от функцията, за да може дъното да бъде достигнато.

```c
void f(unsigned int n)
{
    printf("%d\n", n);
    if(n == 0) return; // Дъно на рекурсията
    f(n - 1); // Рекурсивно извикване
}
```

### Примери

**1. Факториел на число**

```c
#include <stdio.h>

unsigned long long factorial(unsigned int n)
{
    if(n == 0) return 1;
    return n * factorial(n - 1);
}
```

**2. Сума на първите n естествени числа**

```c
#include <stdio.h>

unsigned int sum(unsigned int n)
{
    if(n == 0) return 0;
    return n + sum(n - 1);
}
```

**3. Пример за stack overflow**

```c
#include <stdio.h>

void f(int n)
{   
    // Липсва дъно
    printf("%d\n", n);
    f(n - 1);
}

void g(int n)
{
    // Имаме дъно
    if(n == 0) return;
    printf("%d\n", n);
    // ...но рекурсивното извикване не променя n и никога няма да стигнем до дъното
    g(n);
}
```

## Видове рекурсия

### Директна рекурсия - функцията извиква сама себе си.

```c
void f()
{
    f();
}
```

Може да бъде разделена на 4 подтипа:

- **Опашкова [Tail]** - рекурсия, при която рекурсивното извикване е последната операция в тялото на функцията.

```c
void f(unsigned int n)
{
    if(n == 0) return;
    std::cout << n << '\n';
    f(n - 1);
}
```

- **Главна [Head]** - рекурсия, при която рекурсивното извикване не е последната операция в тялото на функцията.

```c
void f(unsigned int n)
{
    if(n == 0) return;
    f(n - 1);
    std::cout << n << '\n';
}
```

- **Дървовидна [Tree]** - рекурсия, при която има повече от едно рекурсивно извикване.

```c
void f(unsigned int n)
{
    if(n == 0) return;
    std::cout << n << '\n';
    f(n - 1);
    f(n - 1);
}
```

- **Вложена [Nested]** - рекурсия, при която рекурсивната функция се извиква в друга функция.

```c
void f(unsigned int n)
{
    if(n == 0) return;
    std::cout << n << '\n';
    g(n - 1);
}
```

### Индиректна рекурсия - функцията извиква друга функция, която се връща в първоначалната.

Примерът е с две, но могат да бъдат и повече функциите.

```c
void g(unsigned int n)
{
    if(n == 0) return;
    std::cout << n << '\n';
    f(n - 1);
}

void f(unsigned int n)
{
    if(n == 0) return;
    std::cout << n << '\n';
    g(n - 1);
}
```

## Съпоставка с итеративни функции


| Характеристика            | Итеративни функции                         | Рекурсивни функции                          |
|---------------------------|--------------------------------------------|---------------------------------------------|
| **Подход**                | Използват цикли (for, while)               | Използват рекурсивни извиквания             |
| **Простота на кода**      | По-сложен код за разбиране и поддръжка     | По-лесен код за разбиране и поддръжка       |
| **Използване на памет**   | Без допълнителна памет               | Използване на допълнителна (стекова) памет          |
| **Производителност**      | По-бързи, поради липса на стекови операции | По-бавни           |
| **Приложение**            | Подходящи за прости задачи                 | Подходящи за задачи с естествена рекурсия   |
| **Примери**               | Сортиране, търсене                         | Факториел, Фибоначи, обхождане на дървета   |

### Пример показващ предимството на рекурсията пред итеративния подход

Да разгледаме задачата за обхождане на двоично дърво. Рекурсивният подход е по-естествен и лесен за разбиране в сравнение с итеративния.

#### Рекурсивен подход

```c
#include <stdio.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

void inorderTraversal(struct Node* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}
```

#### Итеративен подход

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

void inorderTraversal(struct Node* root) {
    struct Node* stack[100];
    int top = -1;
    struct Node* current = root;

    while (current != NULL || top != -1) {
        while (current != NULL) {
            stack[++top] = current;
            current = current->left;
        }
        current = stack[top--];
        printf("%d ", current->data);
        current = current->right;
    }
}
```

**Важно е отново да се отбележи, че итеративният подход, макар и по-труден за имплементация и четене все още по-оптимален по отношение на използването на памет.**

## Задачи

**Задача 1** Да се направи рекурсивна функция, която намира първата главна буква в низ. Ако низът няма главна буква да се връща '\0'. (Може да използвате и pointer arithmetic)

*Вход: my name is Gosho Изход: G*</br>
*Вход: my name is gosho Изход:*

**Задача 2** Да се направи рекурсивна функция, която принтира пирамида от числа.

*Вход: 4*</br>
*Изход:*</br>
*1*</br>
*2 3*</br>
*4 5 6*</br>
*7 8 9 10*

**Задача 3** Да се напише рекурсивна функция, която приема масив и събира всеки две съседни числа, докато не получи 1 число.

*Вход: [1, 2, 3, 4, 5] Изход: 48*</br>
Поянснение:</br>
[1, 2, 3, 4, 5]</br>
[1 + 2, 2 + 3, 3 + 4, 4 + 5] => [3, 5, 7, 9]</br>
[3 + 5, 5 + 7, 7 + 9] => [8, 12, 16]</br>
[8 + 12, 12 + 16] => [20, 28]</br>
[20 + 28] => 48

**Задача 4** Да се напише рекурсивна функция, която принтира всички числа с 1 до n бита, които нямат последователни 1ци.

*Вход: 4 Изход: 1 2 4 5 8 9 10*
