# Многомерни масиви и статични променливи

## Декларация и инициалиация

```c
#define ROWS = 3;
#define COLS = 4;

int matrix[ROWS][COLS]; // Декларация на матрица с 3 реда и 4 колони

int matrix[ROWS][COLS] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}; // Декларация и инициализация на матрица

int matrix[][COLS] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}; // Декларация на матрица с 3 реда и 4 колони
```

## Достъп до елементите на масив

```c
matrix[1][2] = 10; // matrix = {{1, 2, 3, 4}, {5, 6, 10, 8}, {9, 10, 11, 12}}

matrix[1] // Указател към втория ред на матрицата
```

Пример:
    
```c
#include <stdio.h>

#define ROWS 3
#define COLS 4

int main()
{
    int matrix[ROWS][COLS] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    for(int i = 0; i < ROWS; ++i)
    {
        for(int j = 0; j < COLS; ++j)
        {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
    for (int i = 0; i < ROWS; ++i)
    {
        printf("%d ", matrix[i]);
    }
    return 0;
}
```

## Матрици като аргументи на функции

```c
#include <stdio.h>


void printMatrix(const int matrix[][COLS], int rows, int cols)
{
    for(int i = 0; i < rows; ++i)
    {
        for(int j = 0; j < cols; ++j)
        {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

void modifyMatrix(int **matrix, int rows)
{
    // Example modification: set all elements to 0
    for(int i = 0; i < rows; ++i)
    {
        for(int j = 0; j < COLS; ++j)
        {
            matrix[i][j] = 0;
        }
    }
}

int main()
{
    int matrix[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    printMatrix(matrix, 3);
    modifyMatrix(matrix, 3); // segfault
    printMatrix(matrix, 3);
    return 0;
}
```

Затова трябва да подадем и броя на колоните на матрицата като аргумент на функцията.

```c
void modifyMatrix(int matrix[][COLS], int rows)
{
    // Example modification: set all elements to 0
    for(int i = 0; i < rows; ++i)
    {
        for(int j = 0; j < COLS; ++j)
        {
            matrix[i][j] = 0;
        }
    }
}
```

## Статични променливи

```c
void foo()
{
    static int a = 0; // Статична променлива
    a++;
    std::cout << a << '\n';
}

int main()
{
    foo(); // Извежда 1
    foo(); // Извежда 2
    foo(); // Извежда 3
    return 0;
}
```

## Решето на Ератостен

Алгоритъмът на Ератостен е метод за намиране на всички прости числа до дадено число n. Алгоритъмът работи по следния начин:

```c
#include <stdio.h>

#define N 100

void sieve(int n)
{
    int prime[N + 1];
    for(int i = 0; i <= n; ++i)
    {
        prime[i] = 1;
    }
    prime[0] = prime[1] = 0;
    for(int i = 2; i * i <= n; ++i)
    {
        if(prime[i])
        {
            for(int j = i * i; j <= n; j += i)
            {
                prime[j] = 0;
            }
        }
    }
    for(int i = 0; i <= n; ++i)
    {
        if(prime[i])
        {
            printf("%d ", i);
        }
    }
}

int main()
{
    sieve(100);
    return 0;
}
```

```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

## Задачи

### Задача 1.
Напишете функция, която приема матрица и връща сумата на всички елементи в нея.

### Задача 2.
Напишете програма, която умножава две матрици и извежда резултата на екрана.

### Задача 3.
Напишете програма, която транспонира дадена матрица.

### Задача 4.
Напишете програма, която намира ранга на дадена матрица.

### Задача 5.
Напишете програма, която намира детерминантата на дадена матрица.

### Задача 6.
Напишете програма, която намира обратната матрица на дадена матрица.

### Задача 7 (бонус 1 точка).
Напишете програма, която симулира играта battleship. Играта се разиграва на две полета с размери 10x10. Всеки играч има 5 кораба с размери 1, 2, 3, 4 и 5. Корабите не могат да се препокриват. Играчите се редуват да стрелят върху полето на противника. Играта приключва, когато всички кораби на един от играчите са потопени. При всяко стрелба се извежда съобщение дали играчът е уцелил кораб или не.
